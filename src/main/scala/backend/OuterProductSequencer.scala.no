package saturn.backend

import chisel3._
import chisel3.util._
import chisel3.experimental.dataview._
import org.chipsalliance.cde.config._
import freechips.rocketchip.rocket._
import freechips.rocketchip.util._
import freechips.rocketchip.tile._
import saturn.common._
import saturn.insns._


class OuterProductIO(params : OPUParameters, dLen : Int) extends Bundle {
  // Do these need to be Decoupled? Probably not because all operations of OPU are single cycle sequenced by OPUSequencer
  // val in0    = Input(UInt(dLen.W))
  // val in1    = Input(UInt(dLen.W))
  // val out    = Output(SInt(dLen.W))

  val nmrf       = params.n_mrf_regs,
  val nrows      = dLen/min(params.A_width, params.B_width)
  val ncell_grps = params.C_wdith/min(params.A_width, params.B_width)

  // Write Control
  val write_eg   = Output(UInt(egsTotal.W)) // Forward which element to write to OPU from control logic
  val write_val  = Output(UInt(Bool()))     // Forward write valid to OPU from control logic
  val write mask = Output(UInt(dLen.W))     // Forward write mask to OPU from control logic
  // Array control
  // val opu_en   = Input(Bool())              // DEPRECATED; Indicate to perform MACC
  val read_en  = Input(Vec(nrows, Bool()))
  val row_en   = Input(Vec(nrows, Bool()))
  val load     = Input(Vec(ncell_grps, Bool()))
  val mrf      = Input(UInt(log2Ceil(nmrf).W))
  val macc_en  = Input(Bool())
  val cnfg_en  = Input(Bool())
}


// Create states for FSM
object State extends ChiselEnum { val IDLE, MVIN, MVOUT, OPROD = Value }

// 
class OuterProductUnitSequencerIO(params : OPUParameters, maxDepth: Int, nFUs: Int)(implicit p: Parameters) extends ExecuteSequencerIO(maxDepth, nFUs) {
  val opu_ctrl = Flipped(OuterProductIO(params, dLen))
}


// This implementation assumes that the programmer sets LMUL to the correct value 
// prior to move-ins and move-outs

class OuterProductSequencer(params : OPUParameters, exu_insns: Seq[VectorInstruction])(implicit p: Parameters) extends Sequencer[ExecuteMicroOp]()(p) {
  import State._

  // Hardcode these for now
  val nFUs = 1
  val maxPipeDepth = 1 
  val min_dtype = 8
  val CLUSTER_SIZE = 1 // How many cells per cluster

  // INSTRUCTION ENCODING TODO: Figure out a better way to do this
  val MVIN_FUNCT6  = 0
  val MVOUT_FUNCT6 = 1
  val OPROD_FUNCT6 = 2

  // Maintain Execution Sequencer IO
  val io = IO(new OuterProductUnitSequencerIO(paramsm, maxPipeDepth, nFUs))

  // Ergonomic 
  val varch_ratio     = egsPerVReg                  // Rename because legacy
  val opu_dim         = dLen/min_dtype              // Dimension of PE array 
  val growth_factor   = params.C_wdith/min_inwidth  // Ratio between accumulator and input (TODO: expression is probably wrong for rectangular arrays)
  val mvin_vrf_reads  = varch_ratio*growth_factor   // Number of VRF writes to mvin row of OPU
  val min_inwidth     = min(params.A_width, params.B_width)  

  // Signals
  val mvin_enable  = WireInit(false.B)
  val mvout_enable = WireInit(false.B)
  val oprod_enable = WireInit(false.B)
  val row_load     = Wire(Vec(opu_dim, Bool())) // Enables row to be loaded
  val load         = Wire(Vec(growth_factor, Bool())) // One bit per group of cells written by one DLEM (total # of cells/# of cells written by DLEN)
  // FSM
  val ctrl_st      = RegInit(IDLE)
  val op_egidx     = Reg(UInt(2*log2Ceil(egsPerVReg).W))
  val egidx0       = RegInit(UInt(log2Ceil(egsPerVReg).W), 0.U)
  val egidx1       = RegInit(UInt(log2Ceil(egsPerVReg).W), 0.U)
  val regidx       = Reg(UInt(log2Ceil(varch_ratio).W))   // Index for internal register in matrix register row

  val load_cnt  = RegInit(UInt(log2Ceil(growth_factor).W))
  val mvout_cnt = RegInit(UInt(log2Ceil(dLen/CLUSTER_SIZE).W))  // TODO: this assume no clustering
  
  // Registers for extracting registers (ergonomic)
  val mvin_vreg   = Reg(UInt(5.W))
  val mvin_mrow   = Reg(UInt((vLen/params.A_width).W) // Row within the MRF not the cell array
  val mvin_mreg   = Reg(UInt(log2Ceil(params.n_mrf_regs).W))
  val mvout_vreg  = Reg(UInt(5.W))
  val mvout_mrow  = Reg(UInt((vLen/params.A_width).W)
  val mvout_mreg  = Reg(UInt(log2Ceil(params.n_mrf_regs).W))
  val oprod_vreg0 = Reg(UInt(5.W))
  val oprod_vreg1 = Reg(UInt(5.W))
  val oprod_mreg  = Reg(UInt(log2Ceil(params.n_mrf_regs).W))



  // Default IO Settings
  io.acc_ready := false.B // Signal not used
  io.vgu <> DontCare
  io.pipe_write_req <> DontCare

  // From issue queue
  io.vat          <> DontCare
  io.head         <> DontCare 
  io.vat_head     <> DontCare 
  io.older_writes <> DontCare 
  io.older_reads  <> DontCare 


  //********************************************************************
  io.iss        = Decoupled(issType)
  io.dis        = Flipped(Decoupled(new BackendIssueInst))
  io.dis_stall  = Input(Bool()) // used to disable OOO
  io.seq_hazard = Output(Valid(new SequencerHazard))
  //********************************************************************


  // Main control FSM
  //  - when valid instruction 
  //  - decode intstruction and figure which operation
  //  - trigger FSM, and wait until done
  switch(ctrl_st) {
    is(IDLE) {
      when(io.dis.fire) {
        io.dis.busy := true.B
        mvin_vreg   := io.dis.bits.rs1
        mvin_mrow   := io.dis.bits.rs2
        mvin_mreg   := io.dis.bits.rd
        mvout_vreg  := io.dis.bits.rs1
        mvout_mrow  := io.dis.bits.rs2
        mvout_mreg  := io.dis.bits.rd
        oprod_vreg0 := io.dis.bits.rs1
        oprod_vreg1 := io.dis.bits.rs2
        oprod_mreg  := io.dis.bits.rd

        ctrl_st := MuxCase(IDLE, 
                          (io.dis.bits.funct6 === MVIN_FUNCT6)  -> MVIN,
                          (io.dis.bits.funct6 === MVOUT_FUNCT6) -> MVOUT,
                          (io.dis.bits.funct6 === OPROD_FUNCT6) -> OPROD)
      } .elsewhen {
        ctrl_st := IDLE 
        io.dis.busy := false.B
      }

      // Reset counters
      egidx0   := 0.U
      egidx1   := 0.U
      load_cnt := 0.U

      // Stop VRF requests
      io.rsv1.valid := false.B
      io.rsv2.valid := false.B
      io.rsd.valid  := false.B
      io.rvm.valid  := false.B

      // No need to prioritize funct6 takes single value
      mvin_enable  := io.dis.valid && (io.dis.bits.funct6 === MVIN_FUNCT6)
      mvout_enable := io.dis.valid && (io.dis.bits.funct6 === MVOUT_FUNCT6)
      oprod_enable := io.dis.valid && (io.dis.bits.funct6 === OPROD_FUNCT6)
    }

    is(MVIN){
      // NOTE: you are writing the entire vector 
      when (egidx0 === growth_factor * egsPerVReg) {
        egidx0  := 0.U
        ctrl_st := IDLE
        io.rsv1.valid := false.B
      } otherwise {
        when(io.rsv1.fire) {
          egidx0 := egidx0 + 1.U
          // TODO: Pulse load signal for correct row + cell group
          io.load := UIntToOH(egidx0 % growth_factor)   // TODO: Modulo for quick development; remove in improved version
        } otherwise {
          io.load := UIntToOH(0.U)
        }

        io.row_load  := UIntToOH(mvin_mrow)
        io.rvs1.bits.eg := egidx0
        io.rsv1.valid := true.B
      }

      // Extract source vector register from instruction 
      // Assign to VRF read request bits.eg using getEgId
      // Write value response to OPU MRF

      // Loop by getting the next element group until at the end 
      // Loop exit when element group is at end (example: val dis_tail = dis_next_eidx === dis_vl)

      // Q: How does OPU know which index to write/read? Cells have MRF index

    }

    is(MVOUT){
      when (mvout_cnt === (mvout_mrow + varch_ratio) - 1.U) {
        ctrl_st := IDLE
      } .otherwise {
        mvout_cnt := mvout_cnt + 1.U
      }

      regidx      := Mux(mvout_cnt < varch_ratio, Cat(mvout_mreg, mvout_mrow + mvout_cnt), regidx) // SLOPPY BUT WHATEVER
      io.row_en   := UIntToOH(mvout_mrow)                    // Indicate that row being read
      io.read_en  := (-1).S(io.read_en.getWidth.W).asUInt   // Cells that they are reading
      io.mrf      := Cat(mvout_mreg, mvout_mrow + regidx)   // Indicate the MRF register and row in that MRF

      // TODO: Set Value for VectorPipeWriteReqIO
      // TODO: Indicate write hazard. Assert write hazard for entire vector register (all element groups in vector register)
      io.older_writes := FillInterleaved(varch_ratio, true.B) << (mvout_vreg * varch_ratio.U) // TODO: Should do multiplication by two with shift to avoid overflow

      io.opu_ctrl.write_val  := (mvout_cnt >= mvout_mrow) // Rows zero-indexed 
      io.opu_ctrl.write_eg   := 
      io.opu_ctrl.write_mask :=  


    }

    is(OPROD){
      // Loop
      // Load pair of vectors
      // Send to OPU
      // Loop of next 3 pairs

      egidx0 := op_egidx(egsPerVReg-1, 0)
      egidx2 := op_egidx(2*egsPerVReg-1, egsPerVReg)

      // Load element group from vector
      io.rvs1.bits.eg := egidx0
      io.rvs2.bits.eg := egidx1
      io.rsv1.valid := true.B
      io.rsv2.valid := true.B

      when (io.rvs1.fire && io.rvs2.fire) {
        op_egidx := op_egidx + 1.U
        io.opu_en := true.B
      } .otherwise {
        op_egidx := op_egidx
        io.opu_en := false.B
      }

      when (op_egidx === (2*egsPerVReg-1).U) {
        ctrl_st := IDLE
      }

    }
  }


  // TODO: Need to create mask

  
  io.dis.busy := mvin_enable | mvout_enable | oprod_enable
}



// // Move-Ins take priority
// mvin_enable  := (io.dis.bits.funct6 == MVIN_FUNCT6)
// mvout_enable := (io.dis.bits.funct6 == MVOUT_FUNCT6) && !mvin_enable
// oprod_enable := (io.dis.bits.funct6 == OPROD_FUNCT6) && !mvin_enable && !mvout_enable

// Move-In FSM (ReadIn)
//    Assume Full MRF Load or Partial Load? 
//     - Would need to support in instruction encoding 
//    Access DLEN per cycle up until the number of rows/columns 
// val opu_row_grp = Reg(UInt(log2Ceil(mvin_vrf_reads).W))

// Extract the vector register
// Extract the MRF & row #

// Move-Out FSM (Readout)
// OuterProduct FSM
//    VRF Access
//    - Cycle 1: Two A0 - B0
//    - Cycle 2: Two A0 - B1
//    - Cycle 3: Two A1 - B1
//    - Cycle 4: Two A1 - B0
